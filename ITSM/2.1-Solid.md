Let’s break down the **SOLID principles**, which are five foundational guidelines in **object-oriented programming** (OOP) for writing clean, maintainable, and scalable code. Each letter in SOLID stands for a principle:

---

### **S – Single Responsibility Principle (SRP)**

**Definition:** A class should have **only one reason to change**.
**Explanation:** Each class should do **one thing only**. If a class has multiple responsibilities, changing one feature might break another.

**Example:**

```python
class Invoice:
    def calculate_total(self):
        # calculate total
        pass

    def print_invoice(self):
        # print the invoice
        pass
```

Here, `Invoice` has two responsibilities: calculation and printing. SRP suggests splitting it:

```python
class InvoiceCalculator:
    def calculate_total(self, invoice):
        pass

class InvoicePrinter:
    def print_invoice(self, invoice):
        pass
```

---

### **O – Open/Closed Principle (OCP)**

**Definition:** Software entities should be **open for extension but closed for modification**.
**Explanation:** You should be able to add new functionality without changing existing code, often using inheritance or interfaces.

**Example:**

```python
class Rectangle:
    def area(self):
        return self.width * self.height

class Circle:
    def area(self):
        return 3.14 * self.radius ** 2
```

Instead of modifying a function that calculates areas for new shapes, you can extend the behavior:

```python
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def area(self):
        return 3.14 * self.radius ** 2
```

---

### **L – Liskov Substitution Principle (LSP)**

**Definition:** Subtypes must be **replaceable with their base types** without affecting the program.
**Explanation:** Derived classes should behave like their parent classes. If a function uses a base class, it should work with any subclass without errors.

**Example:**

```python
class Bird:
    def fly(self):
        pass

class Penguin(Bird):
    def fly(self):
        raise Exception("Penguins can't fly")
```

Here, `Penguin` violates LSP because it cannot be used where `Bird` is expected. Better design: separate flying birds from non-flying birds.

---

### **I – Interface Segregation Principle (ISP)**

**Definition:** Clients should **not be forced to depend on interfaces they don’t use**.
**Explanation:** Instead of one large interface, create smaller, specific interfaces so classes only implement what they need.

**Example:**

```python
class Machine:
    def print(self):
        pass
    def scan(self):
        pass
```

A printer-only device would have to implement `scan` unnecessarily. Solution:

```python
class Printer:
    def print(self):
        pass

class Scanner:
    def scan(self):
        pass
```

---

### **D – Dependency Inversion Principle (DIP)**

**Definition:** High-level modules should **not depend on low-level modules**. Both should depend on **abstractions**.
**Explanation:** This makes code flexible and decoupled.

**Example (bad design):**

```python
class MySQLDatabase:
    def connect(self):
        pass

class UserService:
    def __init__(self):
        self.db = MySQLDatabase()  # tightly coupled
```

**Better design (with abstraction):**

```python
class Database:
    def connect(self):
        pass

class MySQLDatabase(Database):
    def connect(self):
        pass

class UserService:
    def __init__(self, db: Database):
        self.db = db  # depends on abstraction, not implementation
```

---

✅ **Summary:**

* **S**: One class, one responsibility.
* **O**: Extend functionality without modifying code.
* **L**: Subtypes must be substitutable for base types.
* **I**: Prefer small, specific interfaces.
* **D**: Depend on abstractions, not concrete classes.

---
