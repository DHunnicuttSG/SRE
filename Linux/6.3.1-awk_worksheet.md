
# awk Practice Worksheet (using `grep_practice` dataset)

Run these from inside the `grep_practice/` directory. Each task shows the intended `awk` command and what it should do. Use `cat` or run the command to verify.

---
## ‚úÖ Easy Level

### 1) Show line numbers for lines containing `ERROR` in `log.txt`
**Command:**
```bash
awk '/ERROR/ {print NR ":" $0}' log.txt
```
**Goal:** Print only matching lines, prefixed with their line number.

### 2) Count how many lines contain `ERROR` in `log.txt`
**Command:**
```bash
awk '/ERROR/ {c++} END {print c+0}' log.txt
```
**Goal:** Print the count (0 if none).

### 3) Case-insensitive count of `warning` in `system.log`
**Command:**
```bash
awk 'BEGIN{IGNORECASE=1} /warning/ {c++} END{print c+0}' system.log
```
**Goal:** Count both `warning` and `WARNING`.

### 4) Print only the IPv4 addresses in `access.log`
**Command:**
```bash
awk '{print $1}' access.log
```
**Goal:** First whitespace-separated field is the client IP.

---
## üîç Intermediate Level

### 5) Sum the response sizes (last column) in `access.log`
**Command:**
```bash
awk '{sum += $NF} END{print sum}' access.log
```
**Goal:** Print the total number of bytes.

### 6) Show the HTTP status code and the request line from `access.log`
**Command:**
```bash
awk -F '"' '{split($3,a); print a[2], $2}' access.log
```
**Goal:** Output like `200 GET /index.html HTTP/1.1`.

### 7) Replace `ERROR`‚Üí`ERR` and print the modified `log.txt`
**Command:**
```bash
awk '{gsub(/ERROR/,"ERR"); print}' log.txt
```
**Goal:** All `ERROR` tokens become `ERR`.

### 8) Print `app.log` without lines containing `DEBUG`
**Command:**
```bash
awk '!/DEBUG/' app.log
```
**Goal:** Filter out matching lines.

### 9) Lines starting with `ERROR` in `server.log`
**Command:**
```bash
awk '/^ERROR/' server.log
```
**Goal:** Use start-of-line anchor.

---
## üí™ Advanced Level

### 10) Extract IPv4 addresses using regex `match()` from `access.log`
**Command:**
```bash
awk 'match($0,/([0-9]{1,3}\.){3}[0-9]{1,3}/){print substr($0,RSTART,RLENGTH)}' access.log
```
**Goal:** Print the matched address from each line.

### 11) Reformat dates `YYYY-MM-DD` ‚Üí `YYYY/MM/DD` in `data.txt`
**Command:**
```bash
awk '{print gensub(/([0-9]{4})-([0-9]{2})-([0-9]{2})/,"\\1/\\2/\\3","g")}' data.txt
```
**Goal:** Convert hyphen dates to slash dates in the output.

### 12) Uppercase only lines containing `critical` (case-insensitive) in `kernel.log`
**Command:**
```bash
awk 'tolower($0) ~ /critical/ {print toupper($0)}' kernel.log
```
**Goal:** Print just those lines, fully uppercased.

### 13) Print `log.txt` with a header and footer (stdout only)
**Command:**
```bash
awk 'BEGIN{print "# Log Start"} {print} END{print "# Log End"}' log.txt
```
**Goal:** Show a header before and a footer after the file.

### 14) Number lines of `animals.txt` with aligned formatting
**Command:**
```bash
awk '{printf "%5d\t%s\n", NR, $0}' animals.txt
```
**Goal:** Produce `lineNumber<TAB>content`.

### 15) Count log levels in `log.txt` and print sorted
**Command (GNU awk):**
```bash
awk '{count[$1]++} END{n=asorti(count,keys); for(i=1;i<=n;i++) printf "%s %d\n", keys[i], count[keys[i]]}' log.txt
```
**Goal:** Print each level and its count.

---
## üî• Challenge
For `log.txt`:
- delete any line containing `DEBUG`
- number the remaining lines (using original line numbers)
- replace `ERROR`‚Üí`ERR`
- show only the first 10 results

**Command:**
```bash
awk '!/DEBUG/ {gsub(/ERROR/,"ERR"); printf "%5d\t%s\n", NR, $0}' log.txt | head -10
```
**Goal:** Combined filtering, substitution, numbering, and truncation.
