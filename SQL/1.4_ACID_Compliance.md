# ACID Compliance

ACID stands for **Atomicity**, **Consistency**, **Isolation**, and **Durability** — four properties that guarantee **reliable database transactions** even when things go wrong (e.g., crashes, power failures, or concurrent updates).

---

## ⚙️ What Is ACID Compliance?

A **transaction** is a single logical unit of work — for example:

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

Here, transferring money from one account to another should **either complete fully or not at all**.
ACID properties make sure that happens safely.

So, a database is **ACID compliant** if it guarantees:

* **Data accuracy**
* **Reliability**
* **Integrity** even after system failures or concurrent transactions

---

## 🧱 The Four ACID Properties

Let’s break them down one by one 👇

---

### 1. **Atomicity** — “All or Nothing”

**Definition:**
A transaction must be treated as a **single unit**.
Either **all operations succeed**, or **none are applied**.

If any part of the transaction fails, the entire transaction is **rolled back** to the original state.

✅ **Example:**
You’re transferring $100 from Account A to Account B:

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

If the second `UPDATE` fails (say, Account B doesn’t exist), the first change is **undone**.
You don’t lose $100 halfway through the transaction.

🧠 **Key idea:** No partial transactions — it’s all or nothing.

---

### 2. **Consistency** — “Valid Before and After”

**Definition:**
A transaction must move the database from **one valid state to another** that satisfies all **rules, constraints, and relationships**.

All **constraints**, **triggers**, and **data types** must remain valid after the transaction.

✅ **Example:**
If a rule states:

> “An account balance cannot be negative”

Then this transaction would fail:

```sql
UPDATE accounts SET balance = balance - 2000 WHERE id = 1;
```

if the balance was only $1000.

🧠 **Key idea:** The database must always respect its **business rules and integrity constraints** (e.g., primary keys, foreign keys, check constraints).

---

### 3. **Isolation** — “Transactions Don’t Interfere”

**Definition:**
When multiple transactions run at the same time,
each one should behave **as if it were the only one** running.

That means **concurrent transactions** shouldn’t cause data conflicts or inconsistencies.

✅ **Example:**
Two users are both trying to book the last seat on a flight.

Without isolation:

* Both might see the seat as “available”
* Both try to book it
* The system double-books the seat 😬

With isolation:

* The first transaction **locks** the row temporarily
* The second transaction waits until the first finishes
* Only one booking succeeds

🧠 **Key idea:** Protects data from concurrent access issues like:

* **Dirty reads** – reading uncommitted changes
* **Non-repeatable reads** – same query returns different results mid-transaction
* **Phantom reads** – new rows appear during a transaction

---

#### 🔸 Isolation Levels (MySQL & SQL Standard)

| Level                | Description                                            | Prevents                     |
| -------------------- | ------------------------------------------------------ | ---------------------------- |
| **Read Uncommitted** | Transactions can see uncommitted changes (unsafe)      | —                            |
| **Read Committed**   | Can only see committed data                            | Dirty reads                  |
| **Repeatable Read**  | Same query always returns same rows (default in MySQL) | Dirty + non-repeatable reads |
| **Serializable**     | Full isolation (most restrictive, least concurrent)    | All read anomalies           |

---

### 4. **Durability** — “Once Committed, It Stays”

**Definition:**
Once a transaction is **committed**, its data changes are **permanent** — even if the system crashes immediately after.

✅ **Example:**
If you commit a transaction that adds $100 to an account,
and then the server loses power,
the new balance must still reflect the deposit after reboot.

🧠 **How it works:**

* Changes are written to **non-volatile storage** (like a transaction log or WAL)
* Upon recovery, the database **replays** or **rolls back** incomplete transactions

---

## 🧠 Summary Table

| Property        | Description                              | Ensures     |
| --------------- | ---------------------------------------- | ----------- |
| **Atomicity**   | All or nothing — no partial transactions | Reliability |
| **Consistency** | Data stays valid and follows all rules   | Integrity   |
| **Isolation**   | Concurrent transactions don’t interfere  | Accuracy    |
| **Durability**  | Once committed, data survives crashes    | Permanence  |

---

## 💾 Real-World Example (Bank Transfer)

Imagine a money transfer between two accounts:

| Step | Operation                                           | ACID Property Ensured |
| ---- | --------------------------------------------------- | --------------------- |
| 1    | Begin transaction                                   | Start atomic unit     |
| 2    | Subtract $100 from Account A                        | Atomicity             |
| 3    | Add $100 to Account B                               | Consistency           |
| 4    | Prevent other transactions from modifying same rows | Isolation             |
| 5    | Commit transaction — write to disk                  | Durability            |

✅ After commit → data is valid and permanent
❌ If failure → all changes rolled back, preserving consistency

---

## 🧩 Why ACID Matters

| Benefit                    | Description                                |
| -------------------------- | ------------------------------------------ |
| 🔒 **Data integrity**      | Prevents corruption or partial updates     |
| ⚡ **Reliability**          | Transactions succeed or fail cleanly       |
| 🤝 **Concurrency control** | Handles multiple users safely              |
| 💥 **Crash recovery**      | Database recovers to last consistent state |

---

## 💬 In Summary

> **ACID compliance** = database transactions that are
> **Atomic**, **Consistent**, **Isolated**, and **Durable** —
> ensuring your data remains **accurate**, **safe**, and **reliable**, even in the face of system failures or concurrent access.

---
