# Normalization

## üß© What Is **Normalization**?

**Normalization** is the process of **organizing data in a database** to **reduce redundancy** (repeated data) and **improve data integrity**.

In simple terms:

> Normalization structures your database so that *each fact is stored in exactly one place.*

This means:

* Each table has a clear purpose.
* Data is **split into logical units**.
* Relationships between data are **defined through foreign keys** rather than duplication.

---

## üß† Origin of the Concept

**Normalization** was first introduced by **Dr. Edgar F. Codd** in **1970**, the same person who **invented the Relational Model of Databases**.

üìò Codd published this idea in his landmark paper:

> *‚ÄúA Relational Model of Data for Large Shared Data Banks‚Äù* (Communications of the ACM, June 1970).

Codd‚Äôs goal was to **make databases more logical, consistent, and flexible**, moving away from rigid, hierarchical storage systems used in early computing.

---

## üéØ The Reasoning Behind Normalization

Before normalization, early databases often contained **duplicate or inconsistent data**.
For example:

| StudentID | StudentName | CourseName | Instructor |
| --------- | ----------- | ---------- | ---------- |
| 1         | Alice       | Math       | Mr. Smith  |
| 2         | Bob         | Math       | Mr. Smith  |
| 3         | Alice       | English    | Ms. Jones  |

### Problems:

* **Redundancy**: ‚ÄúMr. Smith‚Äù appears multiple times.
* **Update anomalies**: If Mr. Smith‚Äôs name changes, you must update every row.
* **Insertion anomalies**: You can‚Äôt add a new instructor until you have a student in their course.
* **Deletion anomalies**: If Alice drops all her courses, her name could be lost completely.

Codd‚Äôs normalization process eliminates these issues by splitting the data into smaller, related tables:

| **Students** |             |
| ------------ | ----------- |
| StudentID    | StudentName |

| **Courses** |            |            |
| ----------- | ---------- | ---------- |
| CourseID    | CourseName | Instructor |

| **Enrollments** |          |
| --------------- | -------- |
| StudentID       | CourseID |

Now, each fact is stored once:

* Instructor name only in **Courses**
* Student name only in **Students**
* Relationship managed by **Enrollments**

---

## üßÆ The Process: Normal Forms

Codd defined a series of **‚ÄúNormal Forms‚Äù**, each building upon the previous one.
Each form enforces stricter rules to eliminate specific types of redundancy.

| Normal Form                       | Main Rule                                                                                         | Solves                 |
| --------------------------------- | ------------------------------------------------------------------------------------------------- | ---------------------- |
| **1NF (First Normal Form)**       | Each column has atomic (indivisible) values; no repeating groups.                                 | Unstructured data      |
| **2NF (Second Normal Form)**      | Must be in 1NF, and all non-key columns depend on the **entire primary key**.                     | Partial dependency     |
| **3NF (Third Normal Form)**       | Must be in 2NF, and all columns depend only on the **primary key**, not on other non-key columns. | Transitive dependency  |
| **BCNF (Boyce-Codd Normal Form)** | Stricter version of 3NF; handles anomalies not covered by 3NF.                                    | Complex dependencies   |
| *(Beyond)*                        | 4NF, 5NF handle multivalued and join dependencies.                                                | Advanced relationships |

---

## üí° Example (Simplified)

Unnormalized table:

| OrderID | Customer | Product | ProductPrice |
| ------- | -------- | ------- | ------------ |
| 1       | Alice    | Laptop  | 1200         |
| 2       | Bob      | Laptop  | 1200         |
| 3       | Alice    | Mouse   | 25           |

Normalized (3NF) structure:

**Customers**

| CustomerID | CustomerName |
| ---------- | ------------ |
| 1          | Alice        |
| 2          | Bob          |

**Products**

| ProductID | ProductName | Price |
| --------- | ----------- | ----- |
| 10        | Laptop      | 1200  |
| 11        | Mouse       | 25    |

**Orders**

| OrderID | CustomerID | ProductID |
| ------- | ---------- | --------- |
| 1       | 1          | 10        |
| 2       | 2          | 10        |
| 3       | 1          | 11        |

‚úÖ Result:

* No duplication of product prices
* Changes to a product‚Äôs price happen **once**
* The data is consistent and scalable

---

## üîç Benefits of Normalization

| Benefit                          | Description                                     |
| -------------------------------- | ----------------------------------------------- |
| üß† **Reduced redundancy**        | No duplicate data stored in multiple places     |
| üí° **Improved integrity**        | Each fact stored once, ensuring accuracy        |
| üîó **Clear relationships**       | Data connections are explicitly defined         |
| üß© **Easier updates**            | Changing one record updates all references      |
| üöÄ **Smaller storage footprint** | Avoids repetition of large text or numeric data |

---

## ‚ö†Ô∏è Tradeoffs (Why Some Databases Denormalize)

While normalization improves **data integrity**, it can also:

* Require **more JOINs** between tables
* Slightly **slow down read performance** in very large databases
* Lead to **complex queries**

That‚Äôs why some high-performance or analytics databases use **denormalization** ‚Äî intentionally adding redundancy to improve speed ‚Äî but always starting from a **normalized base design**.

---

## üß† In Summary

| Term              | Description                                                                            |
| ----------------- | -------------------------------------------------------------------------------------- |
| **Normalization** | The process of structuring a relational database to minimize redundancy and dependency |
| **Introduced by** | Dr. Edgar F. Codd (1970)                                                               |
| **Goal**          | Ensure each fact is stored once and dependencies are logical                           |
| **Core Concept**  | Split data into related tables, use keys and constraints                               |
| **Main Benefit**  | Data integrity, consistency, and scalability                                           |

---

