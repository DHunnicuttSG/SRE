# Denormalization

After learning normalization (1NF, 2NF, 3NF, etc.), it‚Äôs important to understand when and why you might intentionally *undo* some of those rules.
That‚Äôs what **denormalization** is all about.

---

## üß© What Is Denormalization?

**Definition:**

> Denormalization is the process of **intentionally introducing redundancy** into a **normalized database design** to **improve read performance or simplify queries**.

It means **combining tables, duplicating data, or storing derived data** so that you can get results faster ‚Äî even if it violates normal forms.

---

### üß† In Simple Terms:

* **Normalization** = eliminate redundancy for **data integrity**.
* **Denormalization** = reintroduce some redundancy for **speed and simplicity**.

So, while normalization is about *design purity*, denormalization is about *real-world efficiency*.

---

## ‚öôÔ∏è Why Use Denormalization?

Although normalization reduces redundancy and improves data integrity, it can cause:

* Too many **joins** (complex SQL)
* Slower **query performance**, especially in large-scale systems
* High **read latency** in data warehouses or analytics workloads

When performance is more critical than strict normalization, denormalization helps by:
‚úÖ Reducing joins
‚úÖ Simplifying queries
‚úÖ Speeding up reads

---

## üèóÔ∏è Example of Denormalization

### Normalized Design (3NF)

Let‚Äôs say we have a normalized e-commerce schema:

**Customers**

| CustomerID | Name  | Email                                     |
| ---------- | ----- | ----------------------------------------- |
| 1          | Alice | [alice@email.com](mailto:alice@email.com) |

**Orders**

| OrderID | CustomerID | OrderDate  |
| ------- | ---------- | ---------- |
| 101     | 1          | 2025-10-10 |

**OrderDetails**

| OrderID | ProductID | Quantity | Price |
| ------- | --------- | -------- | ----- |
| 101     | 555       | 2        | 20.00 |

If you want to list all orders with customer info, you must join three tables:

```sql
SELECT o.OrderID, o.OrderDate, c.Name, c.Email, d.ProductID, d.Quantity, d.Price
FROM Orders o
JOIN Customers c ON o.CustomerID = c.CustomerID
JOIN OrderDetails d ON o.OrderID = d.OrderID;
```

That‚Äôs efficient for small systems ‚Äî but for millions of rows and high-traffic reads, this can be slow.

---

### Denormalized Design

You could combine **Orders** and **Customers** into one table:

**Orders**

| OrderID | OrderDate  | CustomerID | CustomerName | CustomerEmail                             |
| ------- | ---------- | ---------- | ------------ | ----------------------------------------- |
| 101     | 2025-10-10 | 1          | Alice        | [alice@email.com](mailto:alice@email.com) |

Now you can query all order info **without a join**.

‚úÖ Faster reads
‚ùå But if Alice changes her email, you must update **every order record**.

---

## üß† Common Denormalization Techniques

| Technique                             | Description                                                     | Example                                              |
| ------------------------------------- | --------------------------------------------------------------- | ---------------------------------------------------- |
| **Adding redundant columns**          | Store frequently accessed data directly in another table        | Store `CustomerName` in `Orders`                     |
| **Precomputing aggregates**           | Store totals or averages instead of calculating them on the fly | Store `OrderTotal` instead of summing `OrderDetails` |
| **Combining tables**                  | Merge related tables into one                                   | Merge `Orders` + `Customers`                         |
| **Creating summary tables**           | Store pre-summarized data for reports                           | Daily sales totals by region                         |
| **Storing derived data**              | Store computed fields to avoid recalculation                    | `FullName` = CONCAT(`FirstName`, `LastName`)         |
| **Duplicating data for partitioning** | Keep data copies in multiple places for faster access           | Store user data in each region‚Äôs DB                  |

---

## üßÆ Example: Precomputed Aggregates

**Normalized version (requires calculation):**

```sql
SELECT SUM(Price * Quantity) AS OrderTotal
FROM OrderDetails
WHERE OrderID = 101;
```

**Denormalized version (pre-stored):**

| OrderID | OrderTotal |
| ------- | ---------- |
| 101     | 40.00      |

Now queries like `SELECT OrderTotal FROM Orders;` are instantaneous ‚Äî but if order details change, you must **manually update** the total.

---

## ‚ö†Ô∏è Disadvantages of Denormalization

| Disadvantage               | Description                                            |
| -------------------------- | ------------------------------------------------------ |
| ‚ùå **Data redundancy**      | Data stored in multiple places may become inconsistent |
| ‚ö†Ô∏è **Update anomalies**    | Updates must be made in several tables                 |
| üíæ **Increased storage**   | More disk space used due to duplicated data            |
| üîÑ **Complex maintenance** | Application or triggers must keep data in sync         |
| üßÆ **Integrity risks**     | Easier to introduce errors or stale data               |

---

## üöÄ When to Denormalize

| Scenario                     | Reason                                                 |
| ---------------------------- | ------------------------------------------------------ |
| **Reporting / analytics**    | Pre-aggregated data makes dashboards faster            |
| **High read-to-write ratio** | Systems where reads are far more frequent than writes  |
| **Distributed systems**      | Data is denormalized for replication or partitioning   |
| **Caching layers**           | Denormalized views or materialized tables speed access |
| **Data warehouses (OLAP)**   | Denormalization fits star and snowflake schemas        |

---

## üß© Example: Star Schema (Intentional Denormalization)

In data warehouses, **denormalization is the norm** ‚Äî not the exception.

**Fact Table:** `Sales`
**Dimension Tables:** `Customers`, `Products`, `Time`

Often, you denormalize to create a **Star Schema**:

```
Sales
 ‚îú‚îÄ‚îÄ CustomerName
 ‚îú‚îÄ‚îÄ ProductName
 ‚îú‚îÄ‚îÄ Date
 ‚îú‚îÄ‚îÄ Quantity
 ‚îî‚îÄ‚îÄ TotalAmount
```

This makes analytics queries (like total sales per product per month) extremely fast.

---

## ‚öñÔ∏è Normalization vs. Denormalization Summary

| Aspect            | Normalization                | Denormalization                 |
| ----------------- | ---------------------------- | ------------------------------- |
| Goal              | Reduce redundancy            | Improve performance             |
| Data Integrity    | High                         | Moderate to Low                 |
| Storage           | Efficient                    | More space used                 |
| Query Performance | Slower (more joins)          | Faster (fewer joins)            |
| Complexity        | More tables and joins        | Fewer joins but more redundancy |
| Best for          | OLTP (transactional systems) | OLAP (reporting, analytics)     |

---

## üß† Real-World Analogy

Think of normalization like keeping **a master file cabinet** ‚Äî every document stored once, perfectly organized.
Denormalization is like **making copies of the most used papers** and keeping them on your desk so you can grab them fast ‚Äî at the risk of them getting out of sync.

---

## ‚úÖ In Summary

| Concept        | Description                                         |
| -------------- | --------------------------------------------------- |
| **Definition** | Adding controlled redundancy to improve performance |
| **Purpose**    | Reduce joins and speed up reads                     |
| **Tradeoff**   | Sacrifices integrity and space for speed            |
| **Best For**   | Data warehouses, read-heavy systems                 |
| **Key Risk**   | Data inconsistency                                  |

---
